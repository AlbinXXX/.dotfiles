'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var debug$1 = require('debug');
var difference = require('lodash/difference.js');
var intersection = require('lodash/intersection.js');
var isPlainObject = require('lodash/isPlainObject.js');
var pick = require('lodash/pick.js');
var identity = require('lodash/identity.js');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var React__default = /*#__PURE__*/_interopDefaultCompat(React);
var debug__default = /*#__PURE__*/_interopDefaultCompat(debug$1);
var difference__default = /*#__PURE__*/_interopDefaultCompat(difference);
var intersection__default = /*#__PURE__*/_interopDefaultCompat(intersection);
var isPlainObject__default = /*#__PURE__*/_interopDefaultCompat(isPlainObject);
var pick__default = /*#__PURE__*/_interopDefaultCompat(pick);
var identity__default = /*#__PURE__*/_interopDefaultCompat(identity);
const RouterContext = React__default.default.createContext(null);
function useRouter() {
  const router = React.useContext(RouterContext);
  if (!router) {
    throw new Error("Router: missing context value");
  }
  return router;
}
function isLeftClickEvent(event) {
  return event.button === 0;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function useLink(options) {
  const {
    onClick: onClickProp,
    href,
    target,
    replace = false
  } = options;
  const {
    navigateUrl
  } = useRouter();
  const onClick = React.useCallback(event => {
    if (event.isDefaultPrevented()) {
      return;
    }
    if (!href) return;
    if (onClickProp) {
      onClickProp(event);
    }
    if (isModifiedEvent(event) || !isLeftClickEvent(event)) {
      return;
    }
    if (target) {
      return;
    }
    event.preventDefault();
    navigateUrl({
      path: href,
      replace
    });
  }, [href, navigateUrl, onClickProp, replace, target]);
  return {
    onClick
  };
}
function useIntentLink(options) {
  const {
    intent,
    onClick: onClickProp,
    params,
    replace,
    target
  } = options;
  const {
    resolveIntentLink
  } = useRouter();
  const href = React.useMemo(() => resolveIntentLink(intent, params), [intent, params, resolveIntentLink]);
  const {
    onClick
  } = useLink({
    href,
    onClick: onClickProp,
    replace,
    target
  });
  return {
    onClick,
    href
  };
}
const IntentLink = React.forwardRef(function IntentLink2(props, ref) {
  const {
    intent,
    params,
    target,
    ...restProps
  } = props;
  const {
    onClick,
    href
  } = useIntentLink({
    intent,
    params,
    target,
    onClick: props.onClick
  });
  return /* @__PURE__ */jsxRuntime.jsx("a", {
    ...restProps,
    href,
    onClick,
    ref,
    target
  });
});
const Link = React.forwardRef(function Link2(props, ref) {
  const {
    onClick: onClickProp,
    href,
    target,
    replace,
    ...restProps
  } = props;
  const {
    onClick
  } = useLink({
    onClick: onClickProp,
    href,
    target,
    replace
  });
  return /* @__PURE__ */jsxRuntime.jsx("a", {
    ...restProps,
    onClick,
    href,
    target,
    ref
  });
});
const _hasOWn = Object.prototype.hasOwnProperty;
const hasOwn = _hasOWn.call.bind(_hasOWn);
function isEmpty(object) {
  for (const key in object) {
    if (hasOwn(object, key)) {
      return false;
    }
  }
  return true;
}
function addScope(routerState, scope, scopedState) {
  return scopedState && {
    ...routerState,
    [scope]: scopedState
  };
}
function RouteScope(props) {
  const {
    children,
    scope
  } = props;
  const parent = useRouter();
  const {
    resolvePathFromState: parent_resolvePathFromState,
    navigate: parent_navigate
  } = parent;
  const resolvePathFromState = React.useCallback(nextState => {
    const nextStateScoped = isEmpty(nextState) ? {} : addScope(parent.state, scope, nextState);
    return parent_resolvePathFromState(nextStateScoped);
  }, [parent_resolvePathFromState, parent.state, scope]);
  const navigate = React.useCallback((nextState, options) => {
    const nextScopedState = addScope(parent.state, scope, nextState);
    parent_navigate(nextScopedState, options);
  }, [parent_navigate, parent.state, scope]);
  const scopedRouter = React.useMemo(() => ({
    ...parent,
    navigate,
    resolvePathFromState,
    state: parent.state[scope]
  }), [navigate, parent, resolvePathFromState, scope]);
  return /* @__PURE__ */jsxRuntime.jsx(RouterContext.Provider, {
    value: scopedRouter,
    children
  });
}
function RouterProvider(props) {
  const {
    onNavigate,
    router: routerProp,
    state
  } = props;
  const resolveIntentLink = React.useCallback((intentName, parameters) => {
    const [params, payload] = Array.isArray(parameters) ? parameters : [parameters];
    return routerProp.encode({
      intent: intentName,
      params,
      payload
    });
  }, [routerProp]);
  const resolvePathFromState = React.useCallback(nextState => {
    return routerProp.encode(nextState);
  }, [routerProp]);
  const navigate = React.useCallback(function (nextState) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    onNavigate({
      path: resolvePathFromState(nextState),
      replace: options.replace
    });
  }, [onNavigate, resolvePathFromState]);
  const navigateIntent = React.useCallback(function (intentName, params) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    onNavigate({
      path: resolveIntentLink(intentName, params),
      replace: options.replace
    });
  }, [onNavigate, resolveIntentLink]);
  const router = React.useMemo(() => ({
    navigate,
    navigateIntent,
    navigateUrl: onNavigate,
    resolveIntentLink,
    resolvePathFromState,
    state
  }), [navigate, navigateIntent, onNavigate, resolveIntentLink, resolvePathFromState, state]);
  return /* @__PURE__ */jsxRuntime.jsx(RouterContext.Provider, {
    value: router,
    children: props.children
  });
}
const EMPTY_STATE$1 = {};
function useStateLink(options) {
  const {
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex = false
  } = options;
  if (state && toIndex) {
    throw new Error("Passing both `state` and `toIndex={true}` as props to StateLink is invalid");
  }
  if (!state && !toIndex) {
    console.error(new Error("No state passed to StateLink. If you want to link to an empty state, its better to use the the `toIndex` property"));
  }
  const {
    resolvePathFromState
  } = useRouter();
  const href = React.useMemo(() => resolvePathFromState(toIndex ? EMPTY_STATE$1 : state || EMPTY_STATE$1), [resolvePathFromState, state, toIndex]);
  const {
    onClick
  } = useLink({
    href,
    onClick: onClickProp,
    replace,
    target
  });
  return {
    onClick,
    href
  };
}
const StateLink = React.forwardRef(function StateLink2(props, ref) {
  const {
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex = false,
    ...restProps
  } = props;
  const {
    onClick,
    href
  } = useStateLink({
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex
  });
  return /* @__PURE__ */jsxRuntime.jsx("a", {
    ...restProps,
    href,
    onClick,
    ref
  });
});
const VALID_PARAM_SEGMENT = /^[a-zA-Z0-9_-]+$/;
function createSegment(segment) {
  if (!segment) {
    return null;
  }
  if (segment.startsWith(":")) {
    const paramName = segment.substring(1);
    if (!VALID_PARAM_SEGMENT.test(paramName)) {
      const addendum = segment.includes("*") ? " Splats are not supported. Consider using child routes instead" : "";
      console.error(new Error('Warning: Param segments "'.concat(segment, '" includes invalid characters.').concat(addendum)));
    }
    return {
      type: "param",
      name: paramName
    };
  }
  return {
    type: "dir",
    name: segment
  };
}
function _parseRoute(route) {
  const [pathname] = route.split("?");
  const segments = pathname.split("/").map(createSegment).filter(Boolean);
  return {
    raw: route,
    segments
  };
}
const debug = debug__default.default("state-router");
function arrayify(val) {
  if (Array.isArray(val)) {
    return val;
  }
  return val ? [val] : [];
}
function parseScopedParams(params) {
  return params.map(_ref => {
    let [key, value] = _ref;
    return [parse(key), value];
  });
}
const OPEN = 1;
const CLOSED = 0;
function parse(str) {
  const result = [];
  let i = 0;
  let state = CLOSED;
  while (i < str.length) {
    const nextBracketIdx = str.indexOf("[", i);
    if (nextBracketIdx === -1) {
      result.push(str.slice(i, str.length));
      break;
    }
    if (state === OPEN) {
      throw new Error("Nested brackets not supported");
    }
    state = OPEN;
    if (nextBracketIdx > i) {
      result.push(str.slice(i, nextBracketIdx));
      i = nextBracketIdx;
    }
    const nextClosing = str.indexOf("]", nextBracketIdx);
    if (nextClosing === -1) {
      if (state === OPEN) {
        throw new Error("Unclosed bracket");
      }
      break;
    }
    state = CLOSED;
    result.push(str.slice(i + 1, nextClosing));
    i = nextClosing + 1;
  }
  return result;
}
function matchPath(node, path, searchParams) {
  const parts = path.split("/").filter(Boolean);
  const segmentsLength = node.route.segments.length;
  if (parts.length < segmentsLength) {
    return null;
  }
  const state = {};
  const isMatching = node.route.segments.every((segment, i) => {
    if (segment.type === "dir") {
      return segment.name === parts[i];
    }
    const transform = node.transform && node.transform[segment.name];
    state[segment.name] = transform ? transform.toState(parts[i]) : parts[i];
    return true;
  });
  if (!isMatching) {
    return null;
  }
  const rest = parts.slice(segmentsLength);
  let childState = null;
  const children = typeof node.children === "function" ? arrayify(node.children(state)) : node.children;
  const unscopedParams = removeScope(node.scope, searchParams);
  children.some(childNode => {
    if (childNode) {
      const childParams = childNode.scope ? unscopedParams.filter(_ref2 => {
        let [namespaces] = _ref2;
        return childNode.scope === namespaces[0];
      }) : unscopedParams;
      childState = matchPath(childNode, rest.join("/"), childParams);
      return childState;
    }
    return void 0;
  });
  if (rest.length > 0 && !childState) {
    return null;
  }
  const selfParams = unscopedParams.flatMap(_ref3 => {
    let [namespace, value] = _ref3;
    return namespace.length === 1 ? [[namespace[0], value]] : [];
  });
  const mergedState = {
    ...state,
    ...(childState || {}),
    ...(selfParams.length > 0 ? {
      _searchParams: selfParams
    } : {})
  };
  return node.scope ? {
    [node.scope]: mergedState
  } : mergedState;
}
function _resolveStateFromPath(node, path) {
  debug("resolving state from path %s", path);
  const [pathname, search] = path.split("?");
  const urlSearchParams = Array.from(new URLSearchParams(search).entries());
  const pathMatch = matchPath(node, pathname, parseScopedParams(urlSearchParams));
  debug("resolved: %o", pathMatch || null);
  return pathMatch || null;
}
function removeScope(scope, searchParams) {
  return scope ? searchParams.map(_ref4 => {
    let [namespaces, value] = _ref4;
    return [namespaces[0] === scope ? namespaces.slice(1) : namespaces, value];
  }) : searchParams;
}
function isRecord(value) {
  return isPlainObject__default.default(value);
}
function createMatchError(node, missingKeys, unmappableStateKeys) {
  return {
    type: "error",
    node,
    missingKeys,
    unmappableStateKeys
  };
}
function createMatchOk(node, matchedState, searchParams, child) {
  return {
    type: "ok",
    node,
    matchedState,
    searchParams,
    child
  };
}
function _findMatchingRoutes(node, _state) {
  if (!_state) {
    return createMatchOk(node, {}, []);
  }
  const scopedState = node.scope ? _state[node.scope] : _state;
  const {
    _searchParams: searchParams = [],
    ...state
  } = scopedState || {};
  const requiredParams = node.route.segments.filter(seg => seg.type === "param").map(seg => seg.name);
  const stateKeys = isRecord(state) ? Object.keys(state) : [];
  const consumedParams = intersection__default.default(stateKeys, requiredParams);
  const missingParams = difference__default.default(requiredParams, consumedParams);
  const remainingParams = difference__default.default(stateKeys, consumedParams);
  if (missingParams.length > 0) {
    return createMatchError(node, missingParams, []);
  }
  const scopedParams = searchParams.map(_ref5 => {
    let [key, value] = _ref5;
    return [[key], value];
  });
  const consumedState = pick__default.default(state, consumedParams);
  if (remainingParams.length === 0) {
    return createMatchOk(node, consumedState, scopedParams);
  }
  const children = arrayify((typeof node.children === "function" ? node.children(isRecord(state) ? state : {}) : node.children) || []);
  if (remainingParams.length > 0 && children.length === 0) {
    return createMatchError(node, [], remainingParams);
  }
  const remainingState = pick__default.default(state, remainingParams);
  const childResult = children.map(childNode => _findMatchingRoutes(childNode, remainingState));
  const found = childResult.find(res => res.type === "ok");
  return found ? createMatchOk(node, consumedState, scopedParams, found) : createMatchError(node, [], remainingParams);
}
function _resolvePathFromState(node, _state) {
  debug("Resolving path from state %o", _state);
  const match = _findMatchingRoutes(node, _state);
  if (match.type === "error") {
    const unmappable = match.unmappableStateKeys;
    if (unmappable.length > 0) {
      throw new Error("Unable to find matching route for state. Could not map the following state key".concat(unmappable.length == 1 ? "" : "s", " to a valid url: ").concat(unmappable.map(quote).join(", ")));
    }
    const missingKeys = match.missingKeys;
    throw new Error("Unable to find matching route for state. State object is missing the following key".concat(missingKeys.length == 1 ? "" : "s", " defined in route: ").concat(missingKeys.map(quote).join(", ")));
  }
  const {
    path,
    searchParams
  } = pathFromMatchResult(match);
  const search = searchParams.length > 0 ? new URLSearchParams(encodeParams$1(searchParams)).toString() : "";
  return "/".concat(path.join("/")).concat(search ? "?".concat(search) : "");
}
function bracketify(value) {
  return "[".concat(value, "]");
}
function encodeParamPath(paramPath) {
  const [head, ...tail] = paramPath;
  return tail.length > 0 ? [head, ...tail.map(bracketify)].join("") : head;
}
function encodeParams$1(params) {
  return params.map(_ref6 => {
    let [key, value] = _ref6;
    return [encodeParamPath(key), value];
  });
}
function pathFromMatchResult(match) {
  const matchedState = match.matchedState;
  const base = match.node.route.segments.map(segment => {
    if (segment.type === "dir") {
      return segment.name;
    }
    const transform = match.node.transform && match.node.transform[segment.name];
    return transform ? transform.toPath(matchedState[segment.name]) : matchedState[segment.name];
  });
  const childMatch = match.child ? pathFromMatchResult(match.child) : void 0;
  const searchParams = (childMatch == null ? void 0 : childMatch.searchParams) ? [...match.searchParams, ...childMatch.searchParams] : match.searchParams;
  return {
    searchParams: addNodeScope(match.node, searchParams),
    path: [...(base || []), ...((childMatch == null ? void 0 : childMatch.path) || [])]
  };
}
function addNodeScope(node, searchParams) {
  const scope = node.scope;
  return scope ? searchParams.map(_ref7 => {
    let [namespaces, value] = _ref7;
    return [[scope, ...namespaces], value];
  }) : searchParams;
}
function quote(value) {
  return '"'.concat(value, '"');
}
function decodeJsonParams() {
  let pathsegment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  const segment = decodeURIComponent(pathsegment);
  if (!segment) {
    return {};
  }
  try {
    return JSON.parse(atob(segment));
  } catch (err) {}
  try {
    return JSON.parse(segment);
  } catch (err) {
    console.warn("Failed to parse JSON parameters");
  }
  return {};
}
function encodeJsonParams(params) {
  return params ? btoa(JSON.stringify(params)) : "";
}
function decodeParams(pathSegment) {
  return pathSegment.split(";").reduce((params, pair) => {
    const [key, value] = pair.split("=");
    params[decodeURIComponent(key)] = decodeURIComponent(value);
    return params;
  }, {});
}
function encodeParams(params) {
  return Object.entries(params).filter(_ref8 => {
    let [, value] = _ref8;
    return value !== void 0 && value !== null;
  }).map(_ref9 => {
    let [key, value] = _ref9;
    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
  }).join(";");
}
const route = {
  create: (routeOrOpts, childrenOrOpts, children) => _createNode(normalizeArgs(routeOrOpts, childrenOrOpts, children)),
  intents: base => {
    const basePath = normalize(base).join("/");
    return route.create("".concat(basePath, "/:intent"), [route.create(":params", {
      transform: {
        params: {
          toState: decodeParams,
          toPath: encodeParams
        }
      }
    }, [route.create(":payload", {
      transform: {
        payload: {
          toState: decodeJsonParams,
          toPath: encodeJsonParams
        }
      }
    })])]);
  },
  scope: function (scopeName) {
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }
    const options = normalizeArgs(...rest);
    return _createNode({
      ...options,
      scope: scopeName
    });
  }
};
function normalizeChildren(children) {
  if (Array.isArray(children) || typeof children === "function") {
    return children;
  }
  return children ? [children] : [];
}
function isRoute(val) {
  return val && "_isRoute" in val;
}
function normalizeArgs(path, childrenOrOpts, children) {
  if (typeof path === "object") {
    return path;
  }
  if (Array.isArray(childrenOrOpts) || typeof childrenOrOpts === "function" || isRoute(childrenOrOpts)) {
    return {
      path,
      children: normalizeChildren(childrenOrOpts)
    };
  }
  if (children) {
    return {
      path,
      ...childrenOrOpts,
      children: normalizeChildren(children)
    };
  }
  return {
    path,
    ...childrenOrOpts
  };
}
function normalize() {
  for (var _len2 = arguments.length, paths = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    paths[_key2] = arguments[_key2];
  }
  return paths.reduce((acc, path) => acc.concat(path.split("/")), []).filter(Boolean);
}
const EMPTY_STATE = {};
function isRoot(pathname) {
  return pathname.split("/").every(segment => !segment);
}
function _createNode(options) {
  const {
    path,
    scope,
    transform,
    children
  } = options;
  if (!path) {
    throw new TypeError("Missing path");
  }
  const parsedRoute = _parseRoute(path);
  return {
    _isRoute: true,
    // todo: make a Router class instead
    scope,
    route: parsedRoute,
    children: children || [],
    transform,
    encode(state) {
      return _resolvePathFromState(this, state);
    },
    decode(_path) {
      return _resolveStateFromPath(this, _path);
    },
    isRoot,
    isNotFound(pathname) {
      return this.decode(pathname) === null;
    },
    getBasePath() {
      return this.encode(EMPTY_STATE);
    },
    getRedirectBase(pathname) {
      if (isRoot(pathname)) {
        const basePath = this.getBasePath();
        if (pathname !== basePath) {
          return basePath;
        }
      }
      return null;
    }
  };
}
function useRouterState() {
  let selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity__default.default;
  const {
    state
  } = useRouter();
  return React.useMemo(() => selector(state), [selector, state]);
}
function withRouter(Component) {
  function WithRouter2(props) {
    const router = useRouter();
    return /* @__PURE__ */jsxRuntime.jsx(Component, {
      ...props,
      router
    });
  }
  WithRouter2.displayName = "withRouter(".concat(Component.displayName || Component.name, ")");
  return WithRouter2;
}
const WithRouter = withRouter(props => props.children(props.router));
exports.IntentLink = IntentLink;
exports.Link = Link;
exports.RouteScope = RouteScope;
exports.RouterContext = RouterContext;
exports.RouterProvider = RouterProvider;
exports.StateLink = StateLink;
exports.WithRouter = WithRouter;
exports._createNode = _createNode;
exports.route = route;
exports.useIntentLink = useIntentLink;
exports.useLink = useLink;
exports.useRouter = useRouter;
exports.useRouterState = useRouterState;
exports.useStateLink = useStateLink;
exports.withRouter = withRouter;
//# sourceMappingURL=router.js.map
